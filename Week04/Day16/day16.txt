2차 프로젝트
원장같은거 만드는거
다형성을 이용해서
상속관계를 잡고 기본설계, 상세설계
11월 30일부터 12월 10일까지 코딩
12월 11일 마감

----------------------------------------------------------
추상클래스
     - 공통적인 특성을 추출해서 선언한 클래스, 미완성 설계도
        (대략적으로 틀만 잡아놓은 설계도)
        (= 객체 : 인스턴스화한 클래스)
     - 부모클래스가 공통으로 사용하는 메소드를 
        추상메소드로 만들면 "반드시 재정의"를 해야한다.(★★★★★)
        (안하면 오류 발생)
        일반메소드는 재정의해도 되고 안해도 된다.
     - 대략적인 틀을 잡아놓은 추상클래스를 받아서
        각기 다른 사람들이 자식클래스를 만들어 코드를 만들게 되면
        반드시 재정의하기 때문에 나중에 자식클래스들을 모아서
        코드를 구현할 때 오류가 나지 않는다.
        (추상클래스로 안하면 각기 다른 메소드를 구현하기 때문에
         하나로 합칠 때 오류가 날 수 있다.)
     - 추상클래스 : 일반클래스 또는 추상메소드
        (꼭 추상메서드가 있어야 하는건 아니다.)
     - 추상메소드 = (public abstract) 리턴타입 메소드명();
        추상메소드는 { }가 없다.
     - 추상클래스라고 해서 꼭 추상메소드를 가지지 않아도 된다.
        하지만 추상메소드를 가지고 있으면 반드시 추상클래스로 만들어준다
        (= 클래스명 앞에 abstract를 붙힌다.)
        일반클래스는 추상메소드를 가질 수 없다.
     - 추상클래스는 객체화할 수 없다.
        (다형성 구조는 가능하다.)
     - 추상클래스에는 상수, 생성자, 인스턴스메소드, 추상메소드, 초기화블록,
        정적블록, static메소드 다 가능함
        (default메소드는 인터페이스를 위해 만들어진 메소드라 생성 불가능)
        (static메소드는 생성 가능)

다형성 복습
자식에서 선언한 메소드를 호출할 때
     - 재정의된 메소드가 있으면 호출하였을 때 
        재정의된 메소드가 호출된다.
     - 재정의하지 않은 자식의 메소드를 호출하려면 
        강제 형변환을 해서 호출한다.
        (Down-casting)

public Cat() {
	this.kind="포유류";
}
원래는 super지만 this를 쓰면 
컴퓨터가 현재 클래스인 Cat에서 먼저 찾고 
없으면 부모의 클래스에서 찾는다.

final과 abstract는 같이 쓸 수 없다.
(= final은 상속을 막는데 abstract는 꼭 상속을 해야하기 때문에)
공통적으로 가지는 메소드를 추상메소드로 만들어서 강제로 재정의하게 만든다.


인터페이스 
	- 추상클래스처럼 추상메소드를 갖는다.
	   오직 추상메소드와 상수만을 멤버로 가질 수 있다.
	   (인스턴스 메소드와 정적 메소드는 밑에 설명)
	- 필드는 무조건 상수로 만들어진다.
	   (static final이 생략된다.
	    static만 쓰거나 final만 써도 
	    어차피 결과는 static final)
	- 메소드는 public abstract가 생략된다.
	   (public만 쓰거나 abstract만 쓰거나 아예 안쓰거나
	    결과는 public abstract가 붙어 있는 것)
	- 구현클래스와 연결할 때는 
	   클래스가 아니라서 extends가 아니라 implements
	- 메소드 뒤에 {  }는 앞에 메소드를 구현한다라는 의미.
	   추상메소드는 구현하는게 아니라 틀만 잡는 것이기 때문에
	   { }가 있으면 오류가 발생한다.
	- 1.8버젼 이상에서 허용하는 것	
	   · default void setMute() {  }  <-- 인스턴스 메소드
	      "default"를 붙히면 일반메소드처럼 만들어 놓을 수 있다.
	   · static void aa() {  } <-- 클래스 메소드
	      "static"를 붙히면 일반메소드처럼 만들어 놓을 수 있다.
	   · 생성자, 초기화블록, 정적초기화블록은 만들 수 없다.
	   · 추상클래스는 다 가능하다.
	- 인터페이스는  
	   상수, 추상메소드, 인스턴스메소드, 정적메소드를 가지고 있는 것
	   (인스턴스메소드와 정적메소드는 1.8버젼 이후에서만)
	- 인터페이스끼리는 상속을 할 수 있다.
	   인터페이스끼리 상속을 할 때는 implements가 아니라 extends★
	   <<interface>>
	    인터페이스명
	    또는 글씨가 기울어짐
	   인터페이스끼리는 다중 상속이 가능하다.★★★
	    (클래스는 단일 상속만 가능하다.)
	- 인터페이스는 생성자를 만들 수 없는 미완성된 클래스이므로
	   때문에 그냥 사용할 수 없다.
	   (사용하려면 반드시 일반(구현) 클래스에 연결해야 한다.)
	- 클래스와 인터페이스는 상속이 아니라 연결이라 한다.
	   (클래스 1개와 인터페이스 여러개를 다중으로 연결할 수 있다.)
	- 구현클래스가 추상클래스를 상속받고 2개의 인터페이스를 연결
	   public class 구현클래스 extends 추상클래스 
	   		implements 인터페이스1, 인터페이스2
	- 구현클래스를 객체화하고 부모참조변수를 인터페이스로 할 경우
	   · 같은 부모를 둔 자식인터페이스 2개라도 
	     서로의 멤버에 접근할 수 없다.
	   · 부모인터페이스를 참조변수로 둔다면 
	     부모인터페이스의 멤버만 접근할 수 있다.
	   · 다른인터페이스에 접근하려면 Down-casting을 해서 접근한다.)
	     인터페이스1 x = new 구현클래스();
	     인터페이스2 y = (인터페이스2)x;
	- 인터페이스의 다형성도 다형성의 특징과 동일하다.
	- 인터페이스와 추상클래스의 차이
	   추상클래스(단일상속) / 인터페이스(다중상속)
	   추상클래스의 목적 : 상속을 받아서 기능을 확장시키는 것
	   인터페이스의 목적 : 구현하는 모든 클래스에 대해 특정한 메서드가
			    반드시 존재하도록 강제하는 역할
			    즉, 구현 객체가 같은 동작을 한다는 것을 보장하기 위함	
	
	 
	   

※실무면접볼 때 메모장에 프로그램 짜는 경우도 있으니
ctrl+space를 쓰긴 하지만 코드 구현을 하는 법도 알아야 한다.