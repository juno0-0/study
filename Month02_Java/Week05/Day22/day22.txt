 * API에서 필드에 있는건 클래스명.필드로 바로 쓸 수 있다.
 * Deprecated : 예전에는 있었는데 지금은 더 좋은게 있으니 사용하지 말라는 의미

System Class
 - 운영체제의 도움을 받는 클래스
    주도권이 JVM이 아니라 운영체제에게 있다.
    = 운영체제에게 JVM이 부탁하는 입장
 - java.lang에 들어있는 클래스
 - 필드 : in, out, err
   · in = 키보드입력, 콘솔입력
   · out = 키보드출력, 콘솔출력
   · err = 모니터에러, 콘솔에러
 - getProperty()
   · JVM이 시작할 때 자동 설정되는 시스템의 속성값
   · Key와 Value로 구성되어 있다.
   · getProperties().keySet()을 하면 key만으로 구성된 Set을 얻을 수 있다.
 - gc()
   · JVM에게 가능한한 빨리 힙영역을 치워달라고 요청하는 것
     바로 치워주는건 아님
 - currentTimeMillis()
   · 현재 시간을 밀리초(1/1000) 단위의 long 값으로 리턴
 - nanoTime()
   · 현재 시간을 나노초(1/10^9) 단위의 long 값으로 리턴

Class 클래스
   · 클래스와 인터페이스의 메타 데이터를 관리하는 클래스
     ※ 메타 데이터 = 클래스의 이름, 생성자 정보, 필드 정보, 메소드 정보
   · 다른 클래스에 대한 정보를 보여주는게 목적
 - getClass()
   · 객체.getClass()
   · getClass() 앞에 있는 객체의 클래스의 정보를 보여준다.
     ex)Class 참조변수 = 궁금한 클래스의 객체.getClass();
         String name = 참조변수.getName();
 - getName()
   · 패키지명.클래스명을 문자열로 리턴
 - getSimpleName()
   · 클래스명을 문자열로 리턴
 - getPackage().getName()
   · 클래스가 소속되어 있는 패키지명을 문자열로 리턴

StringTokenizer 클래스
 - 문자열이 특정구분자(& , - 등)로 연결되어 있을 경우
    구분자를 기준으로 분리하기 위해 String 클래스의 split()을 사용하거나,
    StringTokenizer 클래스를 사용
    ※ Token = 혼합된 문자열에서 구분자에 의해서 구분된 것을 분리해서 나온 문자
        ex) 아이유&조유리를 &기준으로 구분했을 때 → 아이유 조유리가 Token
 - split()
   · 정규표현식을 구분자로해서 부분 문자열을 분리한 후 배열에 저장하고 리턴
     ex) text.split("& | , | -");
   · split(구분자,index)
     index번째부터 구분자로 분리
     index가 음수면 앞뒤 상관없이 구분자를 기준으로 다 분리한다.
 - StringTokenizer
   · StringTokenizer st = new StringTokenizer(문자열명, 구분자)
     구분자가 여러개일 경우 "|"를 사용해서 입력
     분리된 문자는 객체에 저장된다.
   · countTokens()
          - 구분되어 있는 갯수(구분이 안되어 있으면 전체를 하나로 보고 1을 리턴)
   · nextToken()
          - 다음 토큰, 하나씩 내보내고, 이전 토큰을 제거한다.
   · hasMoreTokens()
          - 가지고 있는 토큰의 유무를 true/false로 리턴
          - 조건식으로 사용할 수도 있다.
             ex) while(st.hasMoreTokens())
 ※ split()과 StringTokenizer의 차이점
    - split()은 공백도 포함시키지만(배열에 포함시켜줌),
       StringTokenizer는 공백을 제외시킨다(배열에 포함시키지 않음).
       마지막 데이터도 null로 포함시키고 싶다면 split()을 쓴다.
    - split()의 장점 : 정규표현식을 사용해서 다양하게 쪼갤 수 있다.
                 단점 : 속도가 느리다.
    - StringTokenizer의 장점 : 속도가 빠르다.(다량의 데이터)
                             단점 : 정규표현식을 사용할 수 없고, 단순한 문자로만 쪼갤 수 있다.

정규 표현식(Regular Expression)과 Pattern 클래스
 - 정규 표현식 : 문자열이 정해져 있는 형식
   · 이메일, 전화번호같이 형식이 정해져있는 문자열을 제대로 입력했는지
     검증해야 할 때 정규 표현식과 비교한다.
 - 모든 언어가 사용한다.
 - 기호
   · ( ) : 그룹핑, 하나의 문자로 인식
   · { } : 횟수 또는 범위
   · [ ] : 한 개의 문자
   · [abc] : a, b, c 중 하나의 문자
   · [^abc] : a, b, c를 제외한 하나의 문자
   · [a-zA-Z] : a~z, A~Z 중 하나의 문자
   · \w : 한 개의 알파벳 또는 한 개의 숫자, [a-zA-Z_0-9]와 동일
   · \d : 한 개의 숫자, [0-9]와 동일
   · \s : 공백
   · \. : .
   · \ : 뒤에 나오는 특수문자를 출력
   · ? : 없음 또는 한 개
   · * : 없음 또는 한 개 이상
   · + : 한 개 이상
   · | : or
   · {n} : 정확히 n개
   · {n,} : 최소한 n개
   · {n,m} : n개부터 m개까지		ex)\d{3,4} = 숫자 3개나 4개를 의미한다.
 - Pattern.matches(data1, data2)
   · data1과 data2의 정규식이 일치하는지 true/false로 리턴

Arrays 클래스
 - 배열의 조작을 도와주는 클래스
    ※ 조작 = 복사, 항목 정렬, 항목 검색 등
 - 단순한 배열 복사는 System.arraycopy()를 사용할 수 있으나,
    Arrays는 항목 정렬, 항목 검색, 항목 비교같은 기능을 제공
 - Arrays 클래스의 모든 메소드는 static이므로 클래스명으로 접근 가능
 - copyOf(원본배열, 복사할길이)
   · 원본 배열의 처음부터 복사할 길이만큼 복사한 배열을 리턴
   · 복사할 길이는 원본 배열의 길이보다 커도 되며, 복사된 배열의 길이가 된다.
 - copyOfRange(원본배열, 시작인덱스, 끝인덱스)
   · 원본 배열의 시작인덱스부터 끝인덱스 전까지 복사한 배열을 리턴
 ※ arraycopy(원본배열, 원본시작인덱스, 복사될배열, 복사될시작인덱스, 복사길이)
 - equals()
   · 1차 항목의 값만 비교
     (2차원 배열이면 1차원 배열의 주소만 비교)
 - deepEquals()
   · 1차 항목이 서로 다른 배열을 참조할 경우 중첩된 배열의 항목까지 비교
     (2차원 배열이면 2차원 배열의 항목들까지 비교)
 ※ 2차원 배열을 얕은 복제하면 원본과 복사본이 가지고 있는 1차원 배열의 주소는 같다.
    깊은 복제를 하면 원본과 복사본이 가지고 있는 1차원 배열의 주소도 다르다.(새 주소를 줌)
    깊은 복제 → 타입[][] 복제배열 = Arrays.copyOf(원본배열, 원본배열길이)
	        복제배열[n] = Arrays.copyOf(원본배열[n], 원본배열[n]의길이)
 - sort()
   · 기본형 또는 String 배열은 sort()의 매개값으로 지정해주면
     자동으로 오름차순 정렬이 된다.
   · 사용자 정의 클래스 타입일 경우 클래스가 
     Comparable 인터페이스를 구현하고 있어야 정렬이 된다.
     compareTo()는 비교값을 리턴하도록 오버라이딩
     compareTo()의 리턴값(음수, 0, 양수)으로 정렬하는 것
   ※ 그냥 Arrays.sort(배열명)하면 배열안에 있는 무엇을 정렬하는지 모르기 때문에
       compareTo()가 어떻게 재정의 되었느냐에 따라 정렬의 기준이 다르다. 
       - 문자열인 경우
          @Override
	 public int compareTo(Object o){
		return 필드.sompareTo(o.필드);
	 }
       - 정수인 경우
          @Override
	 public int compareTo(Object o){
		return Integer.compare(필드, o.필드);
	 }	
 - binarySearch(배열, 찾는값)
   · 전체 배열 항목에서 찾는 값의 인덱스를 리턴
     없을 경우 음수를 리턴
   · 항목을 검색할 땐 Arrays.sort()로 정렬을 먼저 해야한다.
 - fill(배열, 값)
   · 전체 배열 항목에 동일한 값을 저장
 - fill(배열, 시작인덱스, 끝인덱스, 값)
   · 전체 배열 항목중 시작인덱스부터 끝인덱스까지 동일한 값을 저장
 - hashCode(배열)
   · Object 클래스의 hashCode()를 재정의한 것