Set
 - 저장 순서가 유지되지 않는다.
   · 순서가 필요한 경우 LinkedHashSet을 사용
 - 중복 저장이 안되고 하나의 null만 저장 가능
   · 프로그램에서 중복된 것을 제거하고 싶을 경우
     Set 안에 넣었다가 뺀다.
     다량의 데이터를 받고 종류만 얻고 싶을 경우 사용
     ex) 직원들의 직책을 입력받고 직책의 종류만 얻고 싶을 때
 - index로 관리하지 않기 때문에 index를 매개값으로 갖는 메소드가 없다.

 - HashSet
   · 객체들을 순서 없이 저장하고 동일한 객체는 중복으로 저장되지 않는다.
     - 중복으로 해도 오류는 안나지만 저장되진 않는다.
     - HashSet은 객체를 저장하기 전에 먼저 객체의 hashCode()를 호출해서 
        해시코드를 얻고 이미 저장되어 있는 객체들의 해시코드와 비교함
        만약 동일한 해시코드가 있다면 다시 equals()로 두 객체를 비교해서 
        true가 나오면 동일한 객체로 판단하고 저장하지 않는다.
        문자열의 경우 해시코드는 유니코드
        ※ UniCode : 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계
     - 사용자 정의 클래스의 객체를 넣을 경우 hashCode()와 equals()를 
       오버라이딩 하지 않았으면 매개값이 같아도 중복으로 인식되지 않는다.
       하지만 기본형은 값을 비교하기 때문에 new를 해도 중복이라고 인식(String, Integer etc...)
       hashCode()와 equals()를 재정의했으면 매개값이 같을 때 중복으로 인식
       hashCode() 재정의 : 필드를 다 더한뒤 .hashCode();를 리턴
		         ex) (문자열필드+정수형필드+...).hashCode();
       equals() 재정의 : 매개값으로 받은게 이 타입인지 instanceof로 확인하고 강제 형변환
 		     (강제 형변환을 해야 사용자 정의 클래스에 선언된 필드와 비교할 수 있다.)
	 	     클래스의 필드와 매개변수로 받은 객체에 저장된 필드가 같은지 비교한 결과를 리턴
		     ex) return 필드 == o.필드;
		         여러 개일 경우 return 필드.equals(o.필드)&&필드==o.필드;

 - LinkedHashSet
   · HashSet은 순서가 없지만
     = 무작위로 출력(중복x)
     LinkedHashSet은 순서가 있다.
     = 입력한 순서대로 출력(중복x)

 - 정렬
   · Collections.sort()
     - sort(List<T> list) : 오름차순 정렬, 매개값이 List 참조변수를 넣는다.
     - sort(List<T> list, Comparator<? super T> c) : 내가 정해준 순서로 정렬
   · Collections.sort()는 매개값 타입이 List라서 Set을 List에 넣어야 한다. 
   · Set -> List 바꾸기
     List<set이 저장한 값의 타입> list = new LinkedList<>(set);
   · List -> Set 바꾸기
     Set<list가 저장한 값의 타입> set = new HashSet<>(list);

 - TreeSet
   · 정렬, 검색이 컬렉션 전체에서 가장 빠르다.
   · 객체의 키는 저장과 동시에 정렬의 기준을 따로 명시하지 않으면
     기본적으로 숫자는 오름차순 정렬, 문자는 해시코드로 정렬된다.
     타입이 다양할 경우 유니코드 순서대로 정렬되어 출력
     특수문자 → 숫자 → 대문자 → 소문자 → 한글
   · HashSet처럼 주머니 구조가 아니라 트리 모양의 구조
   · subSet(시작, 끝)
     - 시작부터 끝 전까지의 자료를 리턴
   · subSet(시작, boolean, 끝, boolean)
     - boolean이 true면 앞에 있는 인덱스의 값을 포함
        false면 포함하지 않음.
   · 이진 트리를 기반으로 한 Set 컬렉션
   · 규칙은 맨 처음 값이 맨 위에 있고
     다음 값이 처음 값보다 작으면 노드를 왼쪽에, 크면 노드를 오른쪽에 연결한다.
     비교 대상은 항상 제일 처음 값부터 시작한다.(출입구가 1개)
     중복인 값은 건너뛴다.
   · 예시
     {10, 0, 8, 9, 12, 8, -10, 5, 0}
              10
	 /  ＼
           0     12
         /  ＼  
      -10    8
             /  ＼
           5      9     
     - TreeSet 달아주고 중위오더로 읽으면 오름차순 정렬
     - 최대 검색 수 = 트리 레벨과 동일
     - 장점 : 정렬, 검색이 빠름
     - 단점 : 삽입과 삭제할 때 다른 트리 구조도 변경해야 한다.
                = 처리 시간이 많이 걸림
               삽입과 삭제가 빈번히 일어나면 LinkedHashSet을 쓴다.
               {10, 0, 8, 9, 12, 8, -10, 5, 0}
               여기서 7을 삽입할 경우
                           10
	              /  ＼
                        0     12
                      /  ＼             기존에 연결되어 있던 5를 끊고
                   -10    8            7을 연결한 뒤 5를 7에 연결
                          /  ＼         = 번거롭다.
                        7      9   
                       /
                     5

 - compareTo()
   · 메소드를 사용하려면 Comparable을 implements 받아야 한다.
   · 기본 구조
     기본적으로 오름차순
     if( 조건 ) return -1;
     else if( 조건 ) return 0;
     else return 1;
     비교할 필드와 매개변수로 받은 객체의 필드를 비교
     문자열이면 필드.hashCode()<객체.필드.hashCode()
   · 내림차순으로 변경
     if( 조건 ) return 1;
     else if( 조건 ) return 0;
     else return -1;
     1과 -1의 위치를 바꾸거나,
     필드와 객체의 필드 위치를 바꾼다.     