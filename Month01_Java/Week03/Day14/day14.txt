휠 - 부모클래스(공통적인 요소)
타이어 - 자식클래스들(부모에게 공통적인 요소를 받지만 개별적인 특징을 가지고 있음)
이 때 A회사의 타이어는 미끄러지지 않고
B회사의 타이어는 내구도가 좋음
같은 타이어 규격을 받아서 만들었지만 기능이 다름



다형성 
	- 상속 :  공통적인 멤버를 부모클래스에 넣고 
		자식클래스는 상속받은 뒤 개별적으로 필요한 멤버를 추가
	- 여러 자식들이 부모의 타입으로 똑같이 맞추기 위한 작업
	- 부모클래스의 메소드가 어떤 클래스를 자식 클래스로 두느냐에 따라서
	   다른 기능을 하는 것
	- 같은 타입(자료형)이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질
	- 부모클래스로 타입변환을 허용하는 것

	- 다형성의 성질
		1. 부모 타입으로 자동형변환된 이후에는 부모클래스의 멤버만 접근 가능
		2. 자식 인스턴스의 주소를 참조변수에 담지만 참조변수로 접근 가능한 멤버는 부모의 멤버만 가능
		3. 자식이 부모의 메소드를 재정의했다면 부모의 메소드를 호출해도 재정의한 메소드가 호출된다.
	- 구조(★★★★★) : 부모클래스명 참조변수 = new 자식클래스명();
			  자식의 객체를 인스턴스화할 때 부모타입의 참조변수로 받는것
			ex) TV tv = new CaptionTV();
		    	    부모               자식
			CaptionTV의 인스턴스 주소를 TV클래스타입의 tv에 넣어준다
			= CaptionTV의 주소가 TV클래스타입의 tv의 주소로 찾아간다. 
	- 자식의 인스턴스를 부모타입의 참조변수가 받는 것 = 다형성
	   자식이 인스턴스화를 해서 힙메모리에 올라갈 때
	   부모를 먼저 힙메모리에 올려놓고 올라간다.
	   반대의 경우 부모는 인스턴스화를 해서 힙메모리에 올라갈 때
	   혼자 올라가기 때문에 자식은 힙메모리에 존재하지 않는 상태에서
	   부모의 인스턴스가 참조변수에 주소를 주고 그 주소는 자식을 가르키라는데
	   자식은 메모리에 없기 때문에 오류가 발생하는 것
   	   재정의한 경우 그냥 부모타입의 참조변수로 호출하면
	   재정의한 메소드가 호출된다.

	- 자식만 가지고 있는 멤버를 사용할 때 
	   자식클래스 참조변수 = (자식클래스) 부모타입참조변수; , 강제형변환(down-casting)
	   ex) CaptionTV cctv = (CaptionTV)tv;
	        cctv.으로 접근하면 자식만 가지고 있는 멤버도 사용할 수 있다.
	   


필드의 다형성
	- 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현
	- 타입은 변함이 없지만 실행 도중 어떤 객체를 필드로 넣느냐에 따라 
	   실행 결과가 달라질 수 있음.
	- 객체들이 서로 연결되고 각자의 역할을 하는데 
	   이 객체들은 다른 객체로 교체될 수 있어야 한다.

   Tire frontLeftTire   =   new Tire("앞 왼쪽",6); <-- Car클래스에 객체화 한 부모클래스
         Car car         =   new Car();
    car.frontLeftTire   =   new HankookTire("앞 왼쪽",15);
  Car안에 부모클래스 =   자식클래스 인스턴스
한국타이어의 인스턴스 주소가 car가 가지고 있는 주소로 찾아가면 
그 안에는 타이어타입의 frontLeftTire가 있고 거기에 주소를 넘겨준다.
이동경로
Instance -> car -> Car -> frontLeftTire 
결론
frontLeftTire = Instance 

새로운 XX타이어라는 자식클래스가 생기면 로직을 다시 짤 필요없이
main에서 car.frontLeftTire = new XX타이어("",5);로 바꿔주면 된다.
= 다형성 사용 이유


여러종류의 객체를 배열에 담기
	- 부모타입의 참조변수 배열을 사용하면
	   공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶는다.
	   ex) Test t1 = new TV();
	        Test t2 = new Computer();
	        Test t3 = new Audio();
	      배열을 사용하면
	      Test[] t = new Test[3];
	           t[0] = new TV();
	           t[1] = new Computer();
	           t[2] = new Audio();
	- 클래스배열과 같은데 부모 클래스에 자식 클래스의 객체를 넣는 것


메소드에서 void를 리턴타입으로 주고 
return;으로 리턴값을 안주면 반환하지 않고 메소드 탈출


매개변수의 다형성
	- 매개변수에 자식타입의 객체를 지정할 수 있다.
	   void test(부모클래스 참조변수){
		내용
	   }
	   객체화해서 사용할 때 test(new 자식클래스1());
			      test(new 자식클래스2());
	   혹은 자식클래스1 자식참조변수 = new 자식클래스1();하고
	   test(자식참조변수);

instanceof 
	- 객체타입확인
	   ex) if(parent instanceof Child)
		이 참조변수는 클래스의 참조변수니?
		      parent는 Child의 참조변수니?
		 결과가 true/false라서 보통 if문에 사용한다 

블로그 참고 요약
다형성

A클래스가 부모클래스고 x()라는 메서드가 있고
B클래스가 자식클래스고 y()라는 메서드가 있을 때,
A 참조변수1 = new B();이면
A에 존재하는 멤버만이 B의 멤버가 된다.
참조변수1.x()는 A에 선언되었기 때문에 실행이 된다.
참조변수1.y()는 A에 없기 때문에 실행이 안된다.
만약 A클래스의 x()를 B에서 재정의 했다면
참조변수1.x는 B에서 재정의한 메소드가 실행된다.

여기서 C클래스를 만들고 x()를 재정의한 뒤
C 참조변수2.x()를 실행하면 C에서 재정의한 메소드가 실행된다.

1. 참조변수1로 B 인스턴스의 모든 멤버를 사용할 수 없다.
2. B 참조변수 = new A();는 허용되지 않는다.
   (자식의 참조변수로 부모의 인스턴스를 참조하는 것은 
    존재하지 않는 멤버를 사용하고자 할 가능성이 있어서 허용하지 않는다.
    = 자식을 인스턴스화 하면 부모까지 같이 힙메모리에 올라가지만,
       부모를 인스턴스화 하면 부모만 힙메모리에 올라간다.
       하지만 위에처럼 선언하면 A는 B에 있는 것만 사용할 수 있는데
       A만 힙메모리에 올라가 있는 상황)
3. A에 x=1
   B에 x=2
   A a = new B();
   B b = new B();일 경우
   a.x를 호출하면 1이 나오지만
   b.x를 호출하면 2가 나온다
   (부모타입의 a를 사용하면 부모클래스에 선언된 멤버를 사용
    자식타입의 b를 사용하면 자식클래스에 선언된 멤버를 사용
    만약 자식클래스에 x가 선언되어 있지 않으면 b를 호출했을 때도 a가 나온다)
   그냥 x를 호출하였을 때 A의 x도 2, B의 x도 2가 나온다.
   (인스턴스화를 하였기 때문에 내용 자체는 B가 가지고 있는 멤버들이 나온다.)
   super.x를 하면 A와 B 둘 다 1이 나온다.
   (부모는 결국 A이기 때문에 A가 가지고 있는 값이 나온다.)
   this.x를 하면 A와 B 둘 다 2가 나온다.
   (인스턴스를 둘 다 B를 가지고 있기 때문에 this가 가르키는건 B의 인스턴스 멤버이다.)