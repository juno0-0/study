숙제하기
----------------------------------------------------------------
복습
static 
	- 클래스 로더에서 바이트코드가 JVM에 적재
	- 사용할 때 스택에서 메소드 영역에 있는걸 가져다 쓰는 것
	  (스택에 메모리 공간이 생기는건 아님)

final 
	- 최종값이라는 뜻으로 더 이상 값을 바꿀 수 없음

static final 
	- 상수
	  (자바에서의 상수 : 불변값을 저장하는 필드)

- A에서만 쓸꺼면 final, 각 클래스에서 공통으로 쓸꺼면 static final

final과 static final
	- 둘 다 선언하면 값을 변경할 수 없음
	- final은 다른 클래스에서 접근을 못함
	  선언 먼저 하고 값을 넣어도 된다.(지역변수에서)
	  1번만 초기화 가능
	- static final 은 모든 클래스에서 접근 가능
	  선언과 동시에 값을 넣어야 한다.

static 블록과 instance 블록
- 여러개 만들 수 있다.
- 위에서부터 순서대로 출력된다.
- static 블록 : 프로그램을 실행할 때 메모리에 딱 1번 올라가고 프로그램 종료시 내려옴
	      (공통적으로 쓰는 자료를 사용할 때 static을 쓴다.)

- instance 블록 : 객체를 생성할 때마다 메모리에 올라가고 프로그램 종료시 내려옴
		(임시 변수처럼 잠깐 쓰는 애들을 쓸 때 instance를 쓴다.)

-----------------------------------------------------------------------------------------------
패키지 
	- 클래스를 체계적으로 관리하기 위해 "폴더"를 만들어서 클래스를 저장,관리
	   (기능별로 나눈다. MVC) 
	- Window - Show View - Navigator로 보면 
	  패키지 안에 패키지를 편하게 볼 수 있다
	- 이름은 관례적으로 모두 소문자
	- 패키지 이름은 java로 쓰지 않는다.(사용은 되지만 나중에 헷갈림)
	- 상위패키지.하위패키지.클래스 = 상위 안에 하위 안에 클래스


같은 패키지에 있는건 인스턴스화 하면 오류가 안난다. 
(import나 클래스 위치를 알려주지 않아도 된다.)

다른 패키지에 있는건 클래스의 위치를 알려주면 오류가 안난다
ex) a.aa.Person1 p1 = new a.aa.Person1();

하지만 import하면 그냥 쓰면 된다.
ex ) import a.ab.Person2;
a패키지 안에 ab패키지 안에 Person2를 불러오다(import)
(다른패키지에 있는걸 가지고 올 때)

다른패키지에서 같은 패키지 안에 있는 클래스들을 불러올 때는 *로 대체 가능하다.
*은 바로 앞에 패키지에 있는 클래스만 import하는 것
ex) import c.ca.ccb.It2;	= import c.ca.ccb.*;
     import c.ca.ccb.It3;	   ccb에 있는 클래스만 가능하지 
     import c.ca.ccb.It4;	   ca에 있는 클래스는 따로 해줘야 한다.
			   하위로도 마찬가지.
			   딱 *앞에 패키지 안에 있는 클래스만 import하는 것
※PackageEx01 참고


접근제한자(★★★★★)
	- 자주 사용되고 중요하다.
	클래스는 public, default만 쓸 수 있다. = public을 쓰거나 안쓰거나
	public - 모두 사용 가능
	protected - 같은 패키지만 가능(자식 클래스는 다른 패키지에 있어도 가능)
	default - 접근제한자가 없으면 default가 생략되어 있는 것
		같은 패키지만 가능
	private - 자기 클래스만 가능(같은 패키지여도 접근이 안된다.)

public만 쓰면 코드 오류는 안나지만 보안에 굉장히 취약하다.
기본이 private이고 필요한 경우 default나 public을 써준다.
= 캡슐화

생성자에 private을 붙히면 인스턴스 생성(객체 생성)을 제한할 수 있다.
인스턴스를 1개 만들어놓고 private을 붙혀서 객체 생성을 막으면
들어오는 입구가 1개 뿐인 것
= 싱글톤패턴

멤버에 public이나 static을 붙혀도 클래스가 default면 다른 패키지에서 사용할 수 없다.
(애초에 클래스에 접근 자체가 불가능해서) 

접근제한자가 private인 경우, 같은 클래스 안에서는 자유롭게 사용할 수 있다.

getter&setter
	데이터는 외부에서 접근 할 수 없도록 막고 
	메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.
	
	- getter
	출력할 때
	메소드명이 get변수명이면 변수명이란 변수를 출력한다는 의미
	(get = 값을 불러온다. = 출력) 

	접근제한자 리턴타입 get변수명(){
		return 필드;
	}

	- setter
	필드를 private로 감춰놓고 메소드로 입력을 받는다.
	이 때 메소드명이 set변수명이면 변수명이란 변수에 값을 넣는다는 의미
	(set = 값을 넣는다. = 입력)

	접근제한자 void set변수명(매개변수){
		this.멤버필드 = 매개변수;
	}

	변수명과 get변수명 혹은 set변수명은 동일하게 만들어준다.
	ex) a getA setA

	Alt + Shift + s -> r -> getter와 setter 만들 변수 체크 

싱클톤패턴(★★★★★)
	접근제한자를 이용해서 해당하는 클래스에 접근하는 길을 1개만 만드는 것
	(전체 프로그램에서 단 하나의 객체만 만들 수 있게 하는 것)
	생성자 앞에 private를 붙혀서 클래스 외부에서 new를 못하게 막는다.
	
	- 싱글톤패턴의 구조(★★★★★)
	public class 클래스{
		private static 클래스 참조변수 = new 클래스();
		//private static 객체화;

		private 클래스(){}
		//private 생성자

		//패키지가 다르면 public을 붙힌다.
		static 클래스 getInstance(){
			return 참조변수;
		}
	}

	사용할 때는 static이 붙어있으니까 클래스.getInstance()로 접근한다. 
	- 클래스명 참조변수1 = 클래스명.getInstance();
	- 클래스명 참조변수2 = 클래스명.getInstance();	  
	- 클래스명 참조변수3 = 클래스명.getInstance();
	getInstance()를 받는 참조변수는 3개지만 가지고 있는 힙메모리 주소는 같다.
	getInstance()는 객체화 되어있는 객체를 가지고 있음
	= 1개의 힙메모리 주소를 가지고 있음.


































