복습
싱글톤
	- 전체 프로그램에서 단 하나의 객체만 만들도록 한 것
	- private static Car momCar = new Car();  <-- 얘가 1개뿐인 객체
	  private Car() {}
	  static Car getInstance(){  <-- 얘가 1개뿐인 출구
		return momCar;
	  }
	  main()에서 Car.getInstance()를 호출하면 momCar가 가지고 있는 힙메모리의 주소를 준다.
	  (많이 만들어도 힙메모리에서 주는 주소는 1개만 공유)
	  싱글톤이 아닌 경우 객체를 생성하면 각각의 힙메모리의 주소를 가지고 있다.

	- 구조만 알아두고 API때 어떤 상황에 쓰는지 알려준다고 함

상속
	- 클래스를 기능별로 나눌 때 사용한다.
	   클래스끼리 공통적인 멤버는 클래스 하나에 만들어서 상속을 하는 것
	- 상속을 받으면 부모클래스를 객체화 하지 않고 자식클래스만 객체화해도
	   부모클래스에게 상속받은 멤버를 사용할 수 있다.
	- 부모클래스 = 정적블록, 인스턴스블록, 생성자
	   자식클래스 = 정적블록, 인스턴스블록, 생성자가 있을 경우
	   자식을 객체화할 경우
	   부모정적블록 -> 자식정적블록 -> 부모인스턴스블록 -> 부모생성자 -> 자식인스턴스블록 -> 자식생성자 
	   여기서 자식의 정적블록과 인스턴스 블록을 지우면
	   부모정적블록 -> 부모인스턴스블록 -> 부모생성자 -> 자식생성자
	   블록은 상속되지 않는다.
	   자식을 객체화하면 부모의 블록이 메모리에 올라가서 수행
---------------------------------------------------------------------------------------------------------------
상속2
클래스간의 관계
	- 포함관계(has~a) : "a는 b를 가지고 있다."라고 문장을 만들어서
	   의미가 맞으면 a를 만들 때 b를 import한다.
	   = 다른 클래스의 일부분의 메소드를 쓰고 싶은 경우 import
	   ex) 원은 점을 가지고 있다. 
	        자동차는 바퀴를 가지고 있다. -> 자동차클래스를 만들 때 바퀴클래스를 import해서 쓰는 것
	       
	- 상속관계(is~a) : "자식클래스는 부모클래스이다."라고 문장을 만들어서
	   의미가 맞으면 extends한다.
	   부모클래스는 자식클래스의 공통점을 가지고 있어야 한다.
	   ex)고양이 is a 동물이다.
	       강아지 is a 동물이다.
	       고양이, 강아지의 공통점은 발이 4개인 것이니
	       동물이라는 클래스에 static final int 발=4;를 선언하여 공유
	       바퀴는 is a 자동차다 (x)
	       자동차 is a 바퀴다 (x)

super()
	- 자식이 부모 생성자를 호출할 때 사용한다.
	- this()와 마찬가지로 첫 줄에 1번만 사용할 수 있다.
	- 자식클래스를 객체화할 때 부모클래스의 기본생성자가 자동으로 호출되는 것은
	   자식의 생성자에 super()가 생략되어 있기 때문이다.
	   super(1,2)처럼 부모클래스의 명시적 생성자를 호출하면 기본 생성자가 아닌 명시적 생성자가 호출된다.
	   부모클래스의 생성자를 호출한다는건 부모클래스를 메모리에 올린다는 의미
	- 생성자 호출은 생성자에서 해야 한다.
	- static은 new하기 전에 먼저 메모리에 올라가기 때문에 static은 static만 사용할 수 있다.
	
	- super는 부모의 인스턴스멤버라는 의미
	  (this는 자기 자신의 인스턴스멤버)
	  그렇기 때문에 자식의 정적메소드에서 부모에 선언한 정적필드를 사용하면 오류
	  부모에 선언한 정적필드지만 자식이 호출할 때는 super.정적필드가 되고
	  부모의 인스턴스필드.정적필드는 구조가 맞지 않기 때문에
	  정적필드는 상속으로 쓰지 않고 그냥 클래스명.정적필드로 사용한다.

Object 클래스
	- 모든 클래스의 최상위에 있는 조상클래스
	   다른 클래스를 상속받지 않은 클래스는 다 Object 클래스를 상속받은 것
	   (= 모든 클래스가 Object의 자식 클래스이다.
	    왜냐하면 상속을 해준 부모 클래스가 Object 클래스를 상속받은 것이기 때문에)
	 
native를 붙히면 다른 언어로 만든 코드를 바꿀 수 있다(Java->C, pythod->Java)

Override(재정의)
	- 상속받은 메소드를 수정해서 사용하는 것
	   그냥 쓰면 부모클래스의 메소드가 호출
	   재정의하면 자식클래스의 메소드가 호출
	- 규칙
	       1. 부모 메소드와 자식 메소드가 이름이 같아야한다.(가독성, 기능은 같지만 결과가 다르다.)
		상속관계가 아닌 메소드에서 같은 이름으로 만들면 
		재정의한 메소드가 아니라 그냥 다른 메소드
	       2. 리턴타입, 매개변수 타입,갯수,순서가 같아야한다.
		(완전 똑같은 형태지만 실행내용만 다르게)
	       3. 상속해준 메소드의 접근제한자보다 상속받은 메소드의 접근제한자가 좁은 범위로 변경될 수 없다.
		ex) 부모 = public 자식 = default (x) 반대로 같거나 넓어질 수는 있다.
	       4. 인스턴스 메소드를 static 메소드로 바꿀 수 없다 (반대도 마찬가지)
		(static은 굳이 오버라이딩 하지 않음)
	       5. 예외는 조상 클래스의 메소드보다 많이 선언할 수 없다.
		예외처리도 구조가 있음.
		Exception이 가장 큰 범위
		NullpointException을 부모에게 하고 자식에게 Exception을 하면 오류가 남
		(같거나 작아야 한다.)
	       6. static은 재정의하지 않고 그냥 클래스로 접근해서 사용한다.	

	       규칙이 충족되지 않으면 재정의한 메소드가 아니라 그냥 새로 선언한 메소드가 된다.
	   

String superGetLocation() {
	return super.getLocation();
}
자식클래스에서 메소드를 오버라이딩 했을 때
오버라이딩하지 않은 부모의 메소드를 사용하려면 
자식에서 메소드를 하나 만들어서 거기다 super.부모메소드를 호출한다.
혹은 메인에서 부모클래스를 객체화 하고 부모의 메소드로 접근한다.

@ : 어노테이션 = 아래 메소드가 어떤 기능이다라고 명시해주는 것
      ex) @Override

참조변수를 출력(syso)하면 자동으로 뒤에 .toString()이 생략된다.
toString()은 주소를 문자열로 출력해주는 Object 클래스의 메소드인데,
원하는 클래스에서 재정의해서 toString()의 return 값에 원하는 문자열을 넣어주면
참조변수 출력 시 원하는 문자열이 리턴된다.

final
	- 최종이라는 뜻
	- final 필드 : 값을 변경할 수 없는 필드
		     상속을 해도 final의 값을 변경할 수 없다.
		     사용은 가능하다.
	- final 메소드 : 오버라이딩할 수 없는 메소드
	- final 클래스 : 상속할 수 없는 클래스

protected 
	- 다른 패키지에서 객체화를 하고 import 하더라도 
	   protected가 붙은 멤버에는 접근할 수 없다.
	- 상속을 받은거라 객체화를 하지 않고 그냥 사용가능 
	- 같은 패키지만 사용(다른 패키지는 자식클래스만 가능)