복습
내부클래스의 종류 4가지
   1. 인터페이스 중첩클래스(★★★★★ 가장 많이 사용)
   ex) class A{

	class B{
	     //B는 밖에 있는 A클래스의 멤버를 다 사용할 수 있다.
	       단 A는 B의 멤버에 접근할 수 없다.
	}
       }

   2. 정적 중첩클래스(사용빈도가 낮다.)
   ex) class A{

	static class B{
	     //A에서 static이 붙은 것만 사용할 수 있다.
	}

       }

   3. 로컬 중첩클래스
   ex) method(100);
       //메소드의 매개변수와 로컬변수는 내부클래스로 들어갈 때 원본이 아닌 final 복사본을 준다.
       void method(int b){
	int aa = 10;
	aa = 100;//수정
	b = 200;//수정
	class B{
	     aa = aa+10;//오류, 로컬변수가 내부클래스에선 final이 붙어서 사용만 가능하고 수정은 불가능
	     bb = b;//오류, 매개변수가 내부클래스에선 final이 붙어서 사용만 가능하고 수정은 불가능
	}
	B bClass = new B();
	//메소드 안에서 객체화 후 사용
       }

   4. 익명클래스(★★★★★ 굉장히 많이 사용)
        - { }; 형태면 익명
        1) 익명 자식클래스
        ex) class Parent{
	     void pMethod(){ }		Parent p = new Parent(){
	}			→	     //자식클래스의 멤버들을 넣는 곳
				   	     //여기서 선언한건 여기서만 쓸 수 있음
	class Child extends Parent{		     void cMethod(){ }
	     void cMethod(){ }		};
	}

        2) 익명 구현클래스
        ex) interface I1{
	     void turnOn();			I1 i1 = new I1(){
	}				     //구현객체에 들어갈 내용 코딩(재정의까지!!!)
				→	     @Override
	class C1 implements I1{		     void turnOn(){ }
	     @Override			};
	     void turnOn(){ }
	}
-------------------------------------------------------------------------------------------------------------------
프로그램 오류의 종류
 - 컴파일 예외(일반 예외) : 컴파일시 발생하고, 문법적으로 틀린 경우를 말한다.(빨간 밑줄)
 - 런타임 예외(실행 예외) : 실행시 발생하고, 코드에는 오류가 없는데 실행시 발생한다.
 - 논리적 예외 : 실행은 되지만 의도와는 다르게 동작한다.

 - 에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
 - 예외 : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
 - 둘 다 발생하면 프로그램이 종료된다.
 ※ 예외의 종류가 많기 때문에 예외처리는 자기의 예외만 처리할 수 있다.
     ex) ArrayIndexOutOfBoundsException = ArrayIndexOutOfBounds만 처리할 수 있다.

예외처리란?
 - 비정상적인 종료를 막고 정상적인 실행상태를 유지하는 것
   (오류가 프로그램이 종료되지 않고 끝까지 실행하게 하는 것)	
예외처리 목적
 - 고치는게 아니라 정상적으로 종료시키는 것
예외처리 기본 구조
 - try{
       //오류가 발생할 수도 있는 문장;
       //윗줄에서 오류가 나면 밑에 줄은 실행하지 않고 catch로 넘어간다.★
   }catch(예외처리명 참조변수){
       //오류가 발생했을 때 실행할 문장;
   }

2종류의 예외처리
 - try{
       //오류가 발생할 수도 있는 문장;
   }catch(예외처리명1 참조변수){
       //오류가 발생했을 때 실행할 문장;
   }catch(예외처리명2 참조변수){
       //오류가 발생했을 때 실행할 문장;
       단, 위에 있는 catch에서 예외가 걸리면 밑에 있는 catch는 건너뛴다.★
   }

예외처리를 못해도 반드시 출력해야 할 때
 - try{
       //오류가 발생할 수도 있는 문장;
   }catch(예외처리명1 참조변수){
       //오류가 발생했을 때 실행할 문장;
   }finally {
       //반드시 출력해야 할 문장
       //finally는 예외처리를 하던 못하던 출력한다.
   }

※Scanner도 try-catch로 잡을 수 있다.★★★
   (정수를 받아야 하는데 문자열을 입력한다던지)

Exception
 - 예외 중 가장 큰 범위 
 - 모든 예외를 처리한다.(모든 예외는 Exception을 상속받기 때문에)
   (재정의할 때 자식이 부모의 예외처리 범위보다 큰 예외처리 범위를 가질 수 없다.)
 - 단, 가장 큰 분류는 마지막에 넣어준다.
   (보통 Exception을 쓰면 마지막은 Exception)

예외처리의 범위가 클 수록
catch(예외처리명 참조변수)의 작성을 밑에다 한다.

멀티 catch
 - Java1.7버젼부터 하나의 catch 블록에서 여러 개의 예외를 처리할 수 있는 기능을 넣음
    ex) catch(예외처리명1 | 예뢰처리명2 e)

예외 던지기
 - 예외발생시 예외가 발생한 곳에서 예외처리를 하거나 자기를 호출한 곳에서 예외처리를 하는데
   호출한 곳에서 예외를 처리하는 경우 호출한 곳으로 예외를 던져준다..
 - void 메소드명() throws 예외종류{

   }
 - 호출한 곳은 예외를 받아서 처리해야 한다.
 - 예외의 이동경로 
    ex) main() --> method2() --> a() --> b() 
         b()에서 오류가 발생하면 a()로 오류를 던진다.
         그럼 a()가 받아서 method2()로 던지고,
         method2()가 받아서 main()으로 던지면 main()에서 예외처리를 해야한다.
   순서 : b() throws 예외처리명 --> a() throws 예외처리명 --> method2() throws 예외처리명 --> main()에서 예외처리
           만약 a()에서 다른 종류의 예외가 발생하면
           오류가 발생한 부분 밑에 줄은 수행하지 않고 바로 method()로 넘어간다.
           그리고 a()부터 예외처리명을 하나 늘려준다
           b() throws 예외처리명 --> a() throws 예외처리명, 예외처리명 
           --> method2() throws 예외처리명, 예외처리명 --> main()에서 2개 예외처리
   main()도 메소드라서 throws를 사용할 수 있지만
   왠만하면 main()에서 받은 오류는 main()에서 try-catch로 처리한다.
   왜냐하면 main()이 throws로 오류를 던지면 그걸 받는 곳이 JVM인데
   catch에 실행할 내용을 입력할 수도 없고, 콘솔에 오류가 발생한 것처럼 빨간색 글씨가 나온다.