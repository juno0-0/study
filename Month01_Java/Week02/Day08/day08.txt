클래스 
	- 추상적인 것
	- 객체를 만들기 위한 틀, 설계도
	   객체들이 가지는 공통적인 필드, 메서드를 정의하는 곳

객체
	- 추상적인 것을 실체화 시킨 것
	- 실제로 존재하는 것
	- 엄청 포괄적임 (인스턴스 변수도 객체임) 

객체화(인스턴스화)
	- 추상적인 것을 실체화 하는 과정
	- 클래스로 객체를 만드는 것


main() 안에 만들었을 때
Car momCar = new Car();
Car momCar를 하면 stack에 올라감
new를 만나서 heap에 자리가 생김
거기에 Car()가 자신이 가지는 필드와 메서드를 넣어줌
heap 메모리의 주소를 momCar에 넣어줌
momCar라는 객체(인스턴스)가 생겨남
--------------------------------------------------------------------------------

기본문법 -> API -> 응용프로그램 

설계도를 사용하려면 heap메모리에 올리고 heap메모리 안에 데이터를 넣어야 함.
= new 클래스명()
heap메모리에 올라가 있는 애를 인스턴스라고 부름
메모리에 올리는 작업을 인스턴스화(객체화)라고 함

Car momCar = new Car();
momCar는 참조변수, 객체

클래스에는 속성과 동작(필드와 메서드)을 넣을 수 있음.

필드(명사) = 번호, 국어, 영어, 합계, 평균, 석차

메서드(동사) = 입력한다, 합계를 계산한다, 평균을 계산한다, 석차를 구한다, 출력한다
		과목 합계를 계산한다, 과목 평균을 계산한다
	     UML
	   SungJuk
          --------------------
	     필드
          int number = 0;
              int kor = 0;
              int eng = 0;
             int total = 0;
              int avg = 0;
              int rank = 1;
          -------------------
	     메서드
              void input() -> 입력
                int sum() -> 합계
                int avg() -> 평균
                int rank() -> 석차
             void output() -> 출력
             int subjectSum() -> 과목합계
             int subjectAvg() -> 과목평균

	이런식으로 먼저 그려놓고 시작한다.

클래스에서 다른 클래스로 접근할 때는 객체화를 하고
객체를 통해서 접근한다.
ex) 객체명.필드;
     객체명.메서드();

생성자(construct)
	- 클래스명();
	- new 생성자();(=객체 생성)를 하면 클래스에 있는 필드와 메서드가 힙메모리에
	   올라가면서 자동으로 생성자가 호출된다.
	   (생성자가 없으면 컴파일러가 기본 생성자를 만들어서 호출하고,
	    있으면 기본 생성자를 만들지 않고 있는 것을 호출한다.)
	- 초기화가 목적

컴파일러는 생성자가 1개도 없을 때만 기본생성자를 자동으로 만들어 준다.
만약에 다른 생성자가 1개라도 있으면 기본 생성자를 만들지 않는다.

	접근제한자 클래스명(){
	
	}
	메서드와 똑같이 생겼지만 return 타입이 없고 return값도 없다.


	클래스 변수 = new 생성자(); 하면서 
	동시에 무언가를 해야할 때 생성자를 이용한다.

	매개변수가 있는 모습의 생성자 : 명시적 생성자
	ex ) Student st1 = new Student(2030,"홍길동);
	      public Student(int a, String b){

	      }
	
	Student st0 = new Student(111,"아무개");
	이렇게 다른 생성자와 매개변수가 같으면 새로운 명시적 생성자를
	만드는게 아니라 st1의 생성자를 쓴

	매개변수에 new Student()하면 힙메모리에 주소가 생기고 
	그걸 받을 변수를 만드는 것
	Student st6 = new Student(new Student(), true, "aa");
	public Student(Student a, boolean b, String c){
		a가 힙메모리의 주소를 받을 참조변수
	}

	생성자가 주는 값과 받는 값은
	매개변수의 타입, 순서, 갯수가 같아야 한다.

오버로딩(Overloading)
	- 이름이 같은 생성자,메서드를 여러개 만드는 것
	- 매개변수의 순서, 타입, 갯수가 달라야 만들어진다.
	   (매개변수의 구조가 달라야 한다.) 
	- 매개변수가 자기 타입이 있으면 자기 생성자로 감
	   없으면 자기를 포함하는 타입의 생성자로 들어감
	   (double a, double b)	(double,double)(int,int) 다 들어감
	   (int a, int b)		(int,int)만 들어감
	   될 수 있으면 딱 맞춰서 만드는게 좋다.


new Student();하면 heap메모리에 올라감(heap에 올라가있는걸 인스턴스라고 부름)
올라가자마자 Student() <- 이렇게 생긴 생성자를 자동호출
생성자를 사용자가 만들어놨으면 만들어진 생성자가 호출된다.
new Student(1,2) <- 이렇게 하면 정수2개를 매개변수로 받는 생성자를 호출

Student st1 = new Student("홍길동",2);
Student st2 = new Student("컴퓨터공학","55555");
st1과 st2가 가지고 있는 힙메모리의 주소가 달라서 힙메모리에 있는 값이 다르다.
2개를 같이 출력하려면 
st2.dept;
st2.tel;
st1.hackbun;
st1.name; 이런식으로 값을 가지고 있는 객체를 바꿔준다.

this
	기능1
	- 자기 자신을 뜻한다.
	   내가 지금 있는 클래스(this를 사용한 클래스)에 있는 변수(필드)를 가르킴
	- Person Class
	   this.xxx (Person클래스의 xxx라는 필드를 가르킴)
	   (멤버필드 = 현재클래스의 필드)
	         (멤버 = 클래스에 정의된 필드, 메서드, 생성자)
	- 그 객체의 주소
	
	기능2
	- 생성자에서 다른 생성자 호출시 이용함
	   this(다른 생성자의 매개변수); type은 생략
	- 항상 첫째줄에만 있어야 한다.
	- 항상 1개만 있어야 한다.

	***main메서드를 제외한 메서드나 생성자 안에서만 사용할 수 있다.

정리 
   this는 this를 사용한 클래스의 필드를 가르키는 것.
   Person클래스에서 생성자나 메서드를 만들고 거기서 this를 사용하면 
   그 this는 Person클래스의 필드를 가르킨다.
   Student클래스에서 사용하면 그 this는 Student클래스의 필드를 가르킨다.
	
변수는 같은 이름중에 제일 가까운 곳에 있는걸 먼저 씀




























