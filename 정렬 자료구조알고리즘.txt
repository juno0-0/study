정렬(Sorting)
   · 물건의 크기 순으로 오름차순이나 내림차순으로 나열하는 것
   · 자료 탐색에서 필수★
   · 정렬의 대상
     - 정렬시켜야 될 대상은 record
        record는 필드 단위로 구성
        key 필드로 레코드와 레코드를 구별한다.
   · 모든 경우에 최적인 정렬 알고리즘은 없다.
     각 응용 분야에 적합한 정렬 방법을 사용해야 함
     ex) 레코드의 수량
          레코드 크기
          key의 특성(type)
          메모리 내부/외부 정렬
   · 비교 횟수가 적을 수록 좋은 알고리즘
     이동 횟수가 적을 수록 좋은 알고리즘
     - 단순하지만 비효율적인 방법 : 삽입, 선택, 버블 등
     - 복잡하지만 효율적인 방법 : 퀵, 히프, 합병, 기수 등
     - 내부 정렬(internal sorting) : 모든 데이터가 주기억장치에 저장되어진 상태에서 정렬
     - 외부 정렬(external sorting) : 외부기억장치에 대부분의 데이터가 있고
			       일부만 주기억장치에 저장된 상태에서 정렬
   · 선택 정렬
     - 5 3 8 1 2 7   ← 5와 1을 교환
       1 3 8 5 2 7   ← 3과 2를 교환
       1 2 8 5 3 7   ← 8과 3을 교환
       1 2 3 5 8 7   ← 이미 제자리에 있음
       1 2 3 5 8 7   ← 8과 7을 교환
       1 2 3 5 7 8   ← 정렬 완료
       첫번째 자리부터 차례대로 정렬하는 것

   · 삽입 정렬
     - 5 3 8 1 2 7   ← 초기 상태
       5 3 8 1 2 7   ← 3을 삽입
       3 5 8 1 2 7   ← 8은 이미 제자리
       3 5 8 1 2 7   ← 1을 삽입
       1 3 5 8 2 7   ← 2를 삽입
       1 2 3 5 8 7   ← 7을 삽입
       1 2 3 5 7 8   ← 정렬 완료   
       두번째 자리부터 차례대로 앞의 수와 비교해서
       앞의 수보다 작으면 그 앞으로 삽입
       앞의 수보다 크면 더 이상 이동하지 않음
       = 앞의 수에 자기보다 작은 수가 나올 때까지 앞으로 이동

   · 버블 정렬
     - 5 3 8 1 2 7   ← 초기 상태
       5 3 8 1 2 7   ← 5와 3을 교환
       3 5 8 1 2 7   ← 교환 없음
       3 5 8 1 2 7   ← 8과 1을 교환
       3 5 1 8 2 7   ← 8과 2를 교환
       3 5 1 2 8 7   ← 8과 7을 교환
       3 5 1 2 7 8   ← 하나의 스캔 완료
       첫번째 자리부터 바로 뒤의 수와 비교했을 때
       앞의 수가 뒤의 수보다 크면 교환
       작으면 교환하지 않음
       교환이 없을 경우 다음 수로 다시 비교 시작
       ex) 3번째 줄에서 5와 8을 비교했을 때 8이 크기 때문에
            교환이 없었고 4번째 줄부터 8을 뒤의 수와 비교

   · 셸 정렬
     - 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 빠른 것에서 착안
        삽입 정렬은 요소들이 이웃한 위치로만 이동하므로,
        많은 이동에 의해서만 요소가 제자리를 찾아감
        = 멀리 떨어진 위치로 이동할 수 있으면 
           보다 적게 이동하여 제자리를 찾아감
     - 일정한 간격으로 떨어져있는 자료들끼리 집합을 만들어 
        각각의 집합 내에서 삽입정렬을 수행하는 작업을 반복
        ※ 일정한 간격을 세우는 기준은 원소 전체의 갯수/2를 시작으로
            한 단계가 수행될 때마다 그 값을 반으로 감소시킨다.
            반복 수행하다보면 결국 기준이 1이 될 때까지 반복하며 정렬을 마친다.
     - 전체 원소에 대하여 삽입 정렬을 수행하는 것보다
        부분집합으로 정렬을 하면 비교 연산과 교환 연산의 횟수를 줄일 수 있다.
     - {69, 7, 30, 3, 16, 9, 31, 23}
       전체(8) / 2 = 일정한 간격(4)
       간격이 4만큼 떨어져 있는 자료들끼리 집합
       {69, 16}, {7, 9}, {30, 31}, {3, 23}
       크면 그 앞으로 삽입, 작으면 제자리 = 삽입 정렬
       {16, 7, 30, 3, 69, 9, 31, 23}
       일정한 간격을 반으로 감소 = 2
       간격이 2만큼 떨어져 있는 자료들끼리 집합
       {16, 30, 69, 31}, {7, 3, 9, 23}
       크면 그 앞으로 삽입, 작으면 제자리 = 삽입 정렬
       {16, 3, 30, 7, 31, 9, 69, 23}
       일정한 간격을 반으로 감소 = 1
       간격이 1만큼 떨어져 있는 자료들끼리 집합
       {16, 3, 30, 7, 31, 9, 69, 23}
       3부터 시작해서 자기보다 앞의 수가 크면 그 앞으로 삽입, 작으면 제자리
       {3, 7, 9, 16, 23, 30, 31, 69}

   · 합병 정렬
     - 리스트를 두 개의 균등한 크기로 분할하고
        분할된 부분 리스트를 정렬
        분할된 부분 리스트를 합하여 전체 리스트를 정렬
        ※ 분할 정복 : 문제를 보다 작은 2개의 문제로 분리하고 각 문제를 
		  해결한 다음 결과를 모아서 원래의 문제를 해결하는 전략
		  그래도 해결이 안된다면 반복
     - {27, 10, 12, 20, 25, 13, 15, 22}
       2개의 문제로 분리
       {27, 10, 12, 20}, {25, 13, 15, 22}
       다시 2개의 문제로 분리
       {27, 10}, {12, 20}   {25, 13}, {15, 22}
       다시 분할
        27  10   12  20    25  13   15  22
        합병
       {10, 27}, {12, 20}   {13, 25}, {15, 22}
        합병
       {10, 12, 20, 27}, {13, 15, 22, 25}
        합병
       {10, 12, 13, 15, 20, 22, 25, 27}

   · 퀵 정렬
     - 분할정복법 : 분할 작업을 순환적으로 반복하면서 
                        피벗의 왼쪽 부분 집합과 오른쪽 부분집합을 정렬하는 방법
     ※ 정복 : 기준보다 작은 값은 왼쪽, 큰 값은 오른쪽 부분집합으로 정렬,
                부분집합의 크기가 1 이하가 아니면 순환 호출을 이용해 다시 분할
     - 리스트 가운데서 하나의 원소를 고름(pivot 선정)
       pivot 앞에는 pivot보다 작은 값이 오고,
       뒤에는 pivot보다 큰 값들이 오도록 리스트를 둘로 분할
       분할된 두 개의 리스트에 대해 재귀함수를 통해 이 과정을 반복
     - {66, 10, 1, 34, 5, -10} 
       pivot을 1로 정하면
       1을 기준으로 1보다 작으면 왼쪽, 크면 오른쪽
       {-10, 1, 5, 10, 34, 66}
       {-10, 1}, {10, 34, 5, 6}
       {-10, 1}, {5, 6, 10, 34}
       {-10, 1, 5, 6, 10, 34}

   · 힙 정렬
     - 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해
        고안된 완전 이진 트리를 기본으로 한 자료구조
        ※ 완전 이진 트리 : 삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리
     - 힙에는 부모 노드의 값이 자식 노드의 값보다 항상 큰 최대 힙과
        그 반대인 최소 힙이 존재한다.
     - 순서
        최대 힙을 구성
        현재 힙의 루트는 가장 큰 값이 존재,
        루트의 값을 마지막 요소와 바꾼 후 힙의 사이즈를 하나 줄임
        힙의 사이즈가 1보다 크면 위 과정을 반복

   · 기수 정렬
     - 대부분의 정렬 방법들은 레코드들을 비교함으로써 정렬
       기수 정렬은 레코드를 비교하지 않음
       기수 정렬은 O(dn)의 시간복잡도를 가짐
     - 단점 : 정렬할 수 있는 레코드의 타입 한정(실수, 한글, 한자 등은 정렬 불가)
                레코드의 키들이 동일한 길이를 가지는 숫자나 단순 문자(알파벳 등)만 가능
     - 단순히 버켓에 넣었다가 꺼내면 정렬 된다.
        0 1 2 3 4 5 6 7 8 9 라는 버켓에 {8, 2, 7, 5, 3}을 넣었다가
        {2, 3, 5, 7, 8} 순서로 꺼냄
        만약 1자리수 이상이라면 버켓의 수를 늘린다.
        {28, 93, 39, 81, 62, 72, 38, 26}이 있으면
        낮은 자리수로 먼저 버켓에 넣었다가 뺀다
        {81, 62, 72, 93, 26, 28, 38, 39} 
        그 다음 자리수로 버켓에 넣었다가 뺀다
        {26, 28, 38, 39, 62, 72, 81, 93}

   · 정렬 속도 
     빠른 순서 : 퀵 - 합병 - 힙 - 셸 - 버블 - 선택 - 삽입

