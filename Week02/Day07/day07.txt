코드를 짤 때 수시로 변하는 데이터인지
연에 1번 변하는 데이터인지 파악하고 알맞은 코드를 사용한다.


열거형(enumeration) : 한정된 값(고정된 데이터)만 갖는 경우
		    ex) 요일, 계절, 월, ...
		    여러개의 상수 중에서 하나의 상수를 저장하는 데이터 타입
	
	선언 - 파일명.java
	         새로만들기에서 클래스가 아니라 Enum을 만든다.
	         상수는 관례적으로 대문자로 쓴다.
	          (선언할 때 없는 데이터를 클래스에서 사용하면 오류가 난다.)
	          (필요하다면 선언부에 추가하면 된다.
	          public enum 이름{
		     열거 데이터(상수), 열거 데이터(상수), ...	
	          }
	          이름이 Method영역에 들어가는 것.
	          열거 데이터(상수)들은 Heap에 들어간다.
	          Stack에서 부르면 Heap이 아니라 Method에서 Heap이 준 주소를 넘겨준다.
	          그 주소를 Stack이 받아서 Heap으로 찾아가는 것	      

	사용 - 클래스로 가서 enum을 호출
	         Week today = null	         
	         today(참조변수)가 열거형 Week를 기억해준다.
	         
	         today = week.SUNDAY;

	         열거형은 메소드영역에 올라가서 Heap영역에서 
	         Week 객체인 요일을 받아옴
	         위의 경우 stack영역의 today에 주소를 heap영역의 
	         Week객체인 SUNDAY가 주는게 아니라 
	         메소드영역에 있는 SUNDAY가 넘겨줌.

	          name() : 열거형의 상수값을 리턴해준다.
		          (열거 객체의 문자열을 리턴)
	          ordinal() : 열거 객체의 순번을 리턴
		           (Enum에 생성한 순서)
	          compareTo(Week타입 변수명) : 비교할 때 쓰는 메소드
					  오늘 요일과 입력한 요일(변수명)을 비교
					  (자기보다 앞이면 + 뒤면 -)
					  (자기보다 왼쪽이면 + 오른쪽이면 -)
	          valueOf() : String을 넣으면 Week 타입이 나온다.
			(받을 때도 Week타입으로 받는다)
	          values() : 열거 객체들을 배열로 만들어내는 메소드
			(받을 때도 배열로 받으며 배열 안에 열거객체들을 넣어준다.)


Calendar : 자바의 유틸이라는 패키지에 들어있는 날짜에 관련된 클래스
	        
Singletone type : 이 클래스에 들어가려면 길은 이거 밖에 없다.
		보통은 클래스명 변수명 = new 클래스명();인데
		싱글톤타입은 getInstance()를 통해서만 들어갈 수 있다.
		싱글톤타입은 생성자가 없다.


클래스 : 자바나 객체지향프로그램에서 가장 기본이 되는 것

객체지향언어(OOP:Object Oriendted Programming)
	- 실제 세계를 컴퓨터 속에 구현하는 언어
	- 부품 객체를 먼저 만들고 하나씩 조립해서 프로그램을 완성하는 기법

객체(Object) = 인스턴스(Instance)
	- 물리적으로(실제로) 존재하는 것 (책, 사람, 자동차)
	   (논리적(개념적) = 정의, 구성도)
	- 추상적인 것(회사, 날짜) 중에서 자신의 속성과 동작을 가지는 모든 것
	   (추상 : 필요한 것만 부각시키는 것, 필요한 자료만 끄집어 내는 것)
	   사람이면 속성(이름, 나이) 동작(웃다, 먹다)
	   자동차면 속성(색깔, 속도) 동작(달린다, 멈춘다)
	- 객체는 필드와 메소드로 구성된 자바 객체로 모델링 가능
	   (필드 = 속성, 메소드 = 동작)
	   (필드와 메소드로 생성한 것 = 객체)
	   (이 필드와 메소드를 정의해 놓은 곳이 클래스)
	   (어느것을 속성으로 만들지, 어느것을 동작으로 만들지 잘 생각해야 한다.)

객체의 상호 작용
	- 객체들은 서로 간에 기능을 이용하고 데이터를 주고 받는다.
	   ex) 메소드(매개변수)를 주면 리턴값을 받는다.

객체 지향 프로그램에서의 객체는 다른 객체와 관계를 맺는다.
객체 간의 관계
	- 집합 관계 : 부품과 완성품의 관계(엔진객체+타이어객체+핸들객체 = 자동차객체) 
		     (import하거나, 클래스 안에 클래스를 넣어서 사용(Inner Class))
		     (객체끼리 집합관계를 끊으면 만들 수 없다.)

	- 사용 관계 : 객체가 다른 객체를 사용하는 관계 (import해서 사용) 
		     (객체끼리 사용관계를 끊어도 각 객체는 이상없다. = 끊어도 된다.)

	- 상속 관계 : 종류 객체와 구체적인 사물 객체의 관계 (extends로 상속받음)
		     (자동차 객체는 기계 객체를 상속받은 것)
     		     (객체끼리 집합관계를 끊으면 만들 수 없다.)
     		     (상속 : 위에 있는 클래스와 공통적인 기능을 
			  아래 있는 클래스가 가져와 쓰는 것)

	*설계 : 어떻게 수행해야 되는지에 대한 정의를 작성
		하향식 설계 : 크고 복잡한 문제를 작은 단위로 분해한 다음  
		    	 각각 독립적으로 수행될 수 있게 만드는 것
		     	 (큰걸 보고 내려가면서 작게 만드는 방법)
		상향식 설계 : 작은걸 조합해서 크게 만드는 방법

객체지향 언어의 특징
	캡슐화 : 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것
		궁금한 것만 보여주고 나머지는 감춰두는 것

	상속 : 하위 객체가 상위 객체에게 필요한 것 중에 부모가 가지고 있는 것은 
	        물려받고 없는 것은 만드는 것.

	다형성 : 다양한 성질
		같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질
		기존에 있는것을 새롭게 만든 것으로 바꿔주면 움직이는 것

클래스 : 객체를 만들기 위한 설계도
           클래스에서 객체의 속성과 기능들을 정의하고 이를 통해 객체를 생성.

		       		               인스턴스화	
   순서 : 클래스(설계도) 만들기 -> 필드,메서드 넣기     ->     객체(상품) 만들기 
						    (new 클래스명();)
           
   과정 : 1. 클래스 만들기(설계도) 
	   클래스를 만들지 않으면 객체도 만들 수 없다. 
	   객체를 만들기 위해서 클래스를 만드는 것
           2. 클래스에 필드,메서드 정의하기. 
	   (필드, 메서드 = 멤버)
           3. 클래스를 통해 객체(상품) 만들기(객체화, 인스턴스화) 
	   이 때 Heap영역에 올라간다.
	   * 3번을 하지 않으면 클래스는 2진파일로만 만들어지고 
	      메모리에는 올라가지 않는다.
	하나의 클래스로 여러개의 객체(인스턴스)를 만들 수 있다.
  
           인스턴스(Instance)
	     - 클래스를 통해 만들어진 형태
	     - 인스턴스 멤버(필드, 메서드)
	     - 클래스를 통해 객체를 만드는 과정을 클래스의 인스턴스화(객체화)라 함.
		인스턴스화 : 힙메모리에 클래스를 올리는 것
			    ex) new Person2();

           클래스를 만들면 src폴더에는 main class만 생성되고 
           bin폴더에는 클래스 하나하나 다 생성

           각 클래스를 하나씩 파일로 만들어도 되고 
           클래스 안에 여러개를 만들어도 된다 = 결과는 같음 

           파일당 public은 1개만 있어야 한다.(없어도 된다.)
           단, public이 붙은 클래스와 파일명이 동일해야 한다.
		       
객체 : 현실 세계의 대상
클래스 : 객체들이 공통적으로 가질 수 있는 속성(필드)과 기능(메소드)에 대해 정의해 놓은 것