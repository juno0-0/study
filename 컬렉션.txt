Collection Framework
 - Collection : 객체를 수집해서 저장하는 역할
 - Framework : 사용 방법을 미리 정해놓은 라이브러리
 = 객체를 수집해서 저장한 것의 사용 방법을 미리 정해놓은 라이브러리
 - 다수의 객체를 저장하고 필요할 때마다 꺼내서 사용하는 경우
    가장 간단한 방법은 배열이지만 배열의 단점때문에 컬렉션을 사용
    ※ 배열의 단점 : 생성 시 저장할 수 있는 객체수가 결정
		 객체를 삭제하면 해당 인덱스가 비어있다.
 - 주요 인터페이스 : List, Set, Map
    ※ List와 Set은 공통점이 많아서 
       공통으로 사용하는 메소드만 모아 Collection 인터페이스로 정의하고 
       Collection을 상속받음.

List : 순서 o, 중복 o
 - 객체에 번호를 붙여 상자에 차곡차곡 넣는다.
    = index 필요하면 List
 - ArrayList
   · 저장 용량이 초과하면 자동으로 늘어난다.
     = 객체를 몇개 받을지 모를 때
   · 추가하면 차곡차곡 쌓이지만, 
     삽입·삭제하면 해당 인덱스 뒤에 있는 모든 인덱스들이
     1칸 밀리거나 당겨짐
     = 삽입·삭제시 비효율
 - LinkedArrayList
   · 객체를 체인 구조로 관리함.
     (앞, 뒤 객체의 주소로 객체끼리 연결)
   · 삽입·삭제를 많이 할 경우 사용
 - Vector
   · 동기화된 메소드로 구성되어 있기 때문에
     멀티 스레드 환경에서 안전하게 객체를 추가·삭제할 수 있음
		
Set : 순서 x, 중복 x		
 - 주머니에 객체를 막 넣지만 중복은 안들어감
    = 프로그램에서 중복된 것을 제거하고 싶으면 Set에 넣었다 뺀다.
 - HashSet 		
   · Set의 기본 구조
 - LinkedHashSet
   · 입력한 순서대로 출력하고 싶을 경우 사용
     = 순서가 있음
 - TreeSet	
   · 이진 트리 구조로 객체를 저장
   · 정렬, 검색이 빠름
   · 삽입, 삭제에는 비효율적

Map : Set 구조에 <K, V> 한 쌍인 구조로 담음
 - Key 1개와 Value 1개가 한 쌍인 구조로
   이름표가 달린 값들이 Set 구조로 주머니에 담겨있는 것
 - Key와 Value의 타입은 클래스 or 인터페이스만 가능
 - Key는 중복 x, Value는 중복시 최신화
   · 같은 이름의 Key로 새로운 Value를 넣으면 
     기존 Key에 있던 Value가 사라짐
 - entrySet()
   · 모든 Key와 Value를 Set에 담아서 Set<Map.Entry<K, V> 타입으로 리턴
   · 이름표까지 주머니에 넣은 것
 - HashMap
   · Map의 기본 구조
 - Properties
   · Hashtable의 하위 클래스 = Hashtable의 모든 특성을 가짐
   · Hashtable과 Properties의 차이점
     - Hashtable은 키과 값을 다양한 타입으로 지정 가능
     - Properties는 키와 값을 String 타입으로만 가능★
 - TreeMap
   · 이진 트리 구조로 객체를 저장
   · 정렬, 검색이 빠름
   · 삽입, 삭제에는 비효율적
 - Hashtable
   · 동기화된 메소드로 구성되어 있기 때문에
     멀티 스레드 환경에서 안전하게 객체를 추가·삭제할 수 있음
      (Vector와 동일)



