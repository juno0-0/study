추상클래스
	- 클래스들의 공통요소를 선언해 놓은 미완성 클래스
	- 추상클래스라고 해서 꼭 추상메소드가 있어야 하는건 아니지만,
	   추상메서드가 1개라도 있으면 꼭 추상클래스로 만들어줘야 한다.
	- 부모클래스에서 선언한 추상메소드는 자식클래스에서 반드시 구현해야 한다.
	   단, 자식클래스가 추상클래스면 강제성은 없다. 
	   일반메소드는 자유
	- 부모클래스의 역할은 자식클래스 생성시 도와주는 역할
	- 추상메소드의 구조는
	  abstract 리턴타입 메소드명();
	  구현하지 않고 선언만 하기 때문에 { }가 없다.
	- 일반클래스와 추상클래스의 차이점
	   추상메소드를 가지고 있다.
	   인스턴스가 없어서 객체화를 할 수 없다.
	   (자식클래스를 통해 객체화를 할 수 있지만 목적에 어긋난다.)
	- final과 abstract는 동시에 쓸 수 없다.
	   왜냐하면 final은 재정의를 하지 못하게 하는데,
	   abstract는 반드시 재정의를 해야 하기 때문에

인터페이스 
	- 오직 추상메소드와 상수만 가지고 있다.
	   1.8버젼 이후로는 default메소드와 static메소드도 가질 수 있다.
	- 상수를 선언할 때 static final은 생략이 가능하다.
	- 메소드를 선언할 때 public abstract는 생략이 가능하다.
            - 구현클래스는 인터페이스를 implements한 클래스
	- 인터페이스끼리는 extends로 상속이 가능하고 다중상속이 가능하다.★★★
	- 생성자가 없고, 인스턴스가 없어서 인스턴스화를 할 수 없다.
	   (구현클래스를 통하면 할 수 있다.)
	- 일반클래스가 추상클래스 1개를 상속받고 인터페이스 여러개와 연결할 수 있다.
	- 부모가 같은 인터페이스라도 서로의 멤버에 접근할 수 없다.
	- 인터페이스는 기능, 모듈, 동작별로 구분한다.
	   왜냐하면 인터페이스 한 곳에 멤버를 전부 선언한다면,
	   인터페이스에 정의된 추상메소드가 1개만 필요해도 
	   전체를 재정의해야 하기 때문에
	- 필드의 다형성
	   인터페이스 참조변수 = new 구현클래스();
	- 인터페이스 배열로 구현 객체 관리
	   · 초기값을 알고 있는 경우 
	     인터페이스[] 배열명 = {new 구현생성자(), new 구현생성자()};
	   · 초기값을 모르는 경우
	     인터페이스[] 배열명 = new 인터페이스[2];
	     배열명[0]=new 구현생성자();
	     배열명[1]=new 구현생성자();
	- 강제 형변환
	   구현클래스 안에 정의된 멤버를 사용해야 하는 경우
	    구현클래스 참조변수 = (구현클래스)인터페이스의 참조변수;
	- 매개변수의 다형성
	   메소드(인터페이스 참조변수)일 때
	   매개변수에 구현클래스의 인스턴스를 넣어준다.
	   ex) new 구현클래스생성자()
	- instanceof
	   참조변수 instanceof 인터페이스
	   이 참조변수가 인터페이스 타입이니?
	   true,false로 리턴되며, true면 형변환이 가능하고 false면 형변환이 불가능하다.
	- default메소드
	   · 여기서 default는 키워드이다. (접근제어자가 아니다.)
	   · 바로 쓸 수 없고 구현 객체가 필요하다.
	     객체명.default메소드();
	   · 인터페이스에서 선언과 동시에 구현할 수 있다.
	- default메소드의 용도
	   · 1.8버젼 이후 default메소드를 사용할 수 있는 이유는
	     인터페이스에 새로운 메소드를 추가해야 하는 경우
	     기존에 인터페이스를 사용하던 코드는 재정의를 하지 않아 
	     오류가 발생하기 때문에 default메소드를 사용함으로써 
	     필요한 코드에서만 새로운 메소드를 사용하게 된다.
	- default메소드는 이미 정의된 것을 사용해도 되고,
	   재정의해서 사용해도 된다.
	- 자식인터페이스에서 default메소드를 상속받은 경우
	   · 상속받은 그대로 사용한다.
	   · 재정의해서 사용한다.
	   · 재선언해서 사용한다.
	- static메소드의 경우 인터페이스명으로 바로 접근해서 사용한다.
	   인터페이스명.static메소드();
	- 인터페이스를 new하면 재정의를 해야 한다.

중첩클래스 
	- A와 B라는 클래스(인터페이스)가 있을 때
	   B는 A만 사용하는 경우 B를 A에 넣어준다.
	   B(내부)는 A(외부)의 멤버가 된다.
	- 장점 : B에서 A의 멤버에 쉽게 접근할 수 있다.
	           캡슐화
	- 클래스의 멤버로 선언되면 멤버 클래스
	 1) 인스턴스 멤버 클래스★★★★★
	   · 인스턴스 필드와 메소드만 선언할 수 있다.
	   · 아무런 제약없이 외부클래스의 멤버에 접근할 수 있다.
	   · 외부클래스에서는 내부클래스의 멤버에 접근할 수 없다.
	   · 외부클래스를 객체화하면 외부클래스만 힙영역에 올라간다.
	     = 외부클래스의 참조변수로 내부클래스에 접근할 수 없다.
	   · 내부클래스 객체화
	     → 외부클래스.내부클래스 참조변수 = 외부클래스의 참조변수.new 내부클래스();
	 2) static 멤버 클래스 
	   · 모든 멤버를 선언할 수 있다.
	   · static이 붙은 외부클래스의 정적멤버만 접근할 수 있다.
	   · static이 붙어있기 때문에 내부클래스의 정적멤버는 
	     외부클래스명.내부클래스명.정적멤버로 접근할 수 있다.
	   · 하지만 import하면 내부클래스명 참조변수 = new 내부클래스명();이 가능하다.
	- 메소드 안에 선언되면 로컬 클래스
	   · 인스턴스 필드와 메소드만 선언할 수 있다.
	   · 필드와 메소드 선언은 내부클래스 안에 하고, 객체화는 내부클래스가 있는 메소드 안에 한다.
	   · 외부클래스의 메소드 안에 내부클래스를 선언한다.
	   · 메소드의 지역안에 있기 때문에 메소드를 호출할 때만 사용할 수 있다.
	   · 외부클래스로 내부클래스가 있는 메소드를 호출하면 사용할 수 있다.
	   · 접근제어자나 static을 붙일 수 없다. (메소드 안에 있어서 접근을 제한할 필요가 없다.)
	     static은 메소드는 "}"를 만나면 종료되는데 static은 메모리에 남아있어야 하기 때문에
	   · 외부클래스에 있는 인스턴스 필드는 내부클래스에서 수정이 가능하지만,
	     메소드에 있는 필드는 내부클래스에서 사용만 가능하다.	   
	- 중첩클래스의 접근 제한
	  1) 바깥 필드와 메소드에서 사용 제한
	   · 인스턴스 멤버 클래스는 외부클래스의 인스턴스 필드와 메소드에서
	      객체화가 가능하지만, 정적 필드와 메소드에서는 불가능하다.
                  (static이 메모리에 올라갈 때 인스턴스 멤버 클래스는 존재하지 않기 때문에)
	   · 정적 멤버 클래스는 모든 필드와 메소드에서 객체화를 할 수 있다.
	  2) 로컬 클래스에서 사용 제한
	   · 로컬 클래스 내부에서는 외부클래스의 멤버를 제한 없이 사용할 수 있다.(인스턴스 멤버 클래스와 같음)
	   · 메소드의 매개변수나 로컬변수를 로컬 클래스에서 사용할 때★★★
	      로컬 클래스의 객체는 메소드 실행이 끝나도 힙영역에 존재하기 때문에 계속 사용 가능.
	      하지만 매개변수나 로컬변수는 메소드 실행이 끝나면 스택영역에서 사라지기 때문에 문제 발생
	      다른 메소드의 매개변수나 로컬변수가 내부클래스에 들어올 때
	      매개변수나 로컬변수의 원본이 아닌 복사본이 들어가고 거기에 final이 자동으로 붙는다.
	      예를 들어 int a=5;라는 필드가 메소드에 선언된 경우
	      a는 선언된 메소드에서 초기값을 변경할 수 있지만, 내부클래스에 있는 a는 final이 붙은 복사본이라서
	      수정할 수도 없고, 메소드에 선언된 a를 수정하면 복사본과 원본의 값이 다르기 때문에
	      복사본에 오류가 나는 것이다. 
	  3) 중첩클래스에서 외부클래스 참조 얻기
	   · this
	     외부클래스와 내부클래스에 이름이 같은 멤버가 있는 경우,
	      this로 어느 클래스인지 알려준다.
	     외부클래스를 가르키는 경우 외부클래스.this.외부클래스멤버;
    	     (외부클래스 안에 인스턴스 필드인 외부클래스멤버를 호출이라는 뜻)
	     내부클래스는 그냥 쓰면 된다. = 내부클래스멤버;

중첩 인터페이스
	- 클래스 안에 선언된 인터페이스
	- 다른 클래스와 연결할 때 
	   implements 외부클래스명.인터페이스명
	- 익명 자식 객체 생성
	   · 

객체화
클래스명 참조변수 = new 클래스명();

다형성
부모클래스명 참조변수 = new 자식클래스명();

익명클래스
추상클래스명 참조변수 = new 추상클래스명(){ };
인터페이스명 참조변수 = new 인터페이스명(){ };
★★★★★{ }; = 익명클래스라는 뜻

익명객체(클래스)
	- 이름이 없는 객체
	- 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성 가능
	  1) 익명 자식 객체 생성
	   · 익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명 자식 객체 내부에서만 사용되고
	     외부에서는 접근할 수 없다.(이름이 없기 때문에 그리고 다형성이라서)
	     왜냐하면 익명 자식 객체는 부모 타입 변수에 들어가기 때문에 부모 타입에 선언된 것만 사용 가능
	     (부모클래스 참조변수 = new 부모클래스() { 익명 자식 객체 };)
	   · { }; 안에 있는게 클래스라서 인스턴스 멤버를 선언할 수 있지만
	     static은 클래스명으로 접근하는데 이름이 없어서 선언도 할 수 없다.
	   · Parent 참조변수 = new Child(); 에서 오로지 new Child();를 하기 위해 자식클래스를 만든 경우
	     자식클래스를 만들지 않고 그냥 익명 자식 객체를 만든다.
	     Parent 참조변수 = new Parent(){ };
	   · 생성자를 만들 수 없다 = 이름이 없어서 = 일반클래스와의 차이
	  2) 익명 구현 객체 생성
	   · { }; 안에는 모든 추상메소드를 재정의 해야 한다.
	   · 필드와 메소드를 선언할 수 있지만 익명 객체에 선언한 메소드에서만 사용할 수 있다.
	  3) 익명 객체의 로컬 변수 사용
	   · 익명 객체 내부에서는 외부클래스의 필드나 메소드는 제한 없이 사용 가능
	   · 문제는 메소드의 매개변수나 로컬변수를 익명 객체에서 사용할 때
	   · 위에 로컬 클래스에서 사용 제한 참고

추상클래스와 인터페이스의 공통점
- 인스턴스가 없다.
- 자식에게 추상메소드를 상속해주면 자식은 반드시 재정의해야 한다.

